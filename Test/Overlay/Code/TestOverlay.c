#include <stdio.h>
#include <conio.h>
#include <stdlib.h>

typedef char bool;
#define nullptr NULL
#define true 1
#define false 0

extern void _MENU_LOAD__[];
extern void _LEVEL1_LOAD__[];
extern void _LEVEL2_LOAD__[];

extern void foo(void);
extern void bar(void);
extern void foobar(void);

// Functions resident in an overlay can call back functions resident in the
// main program at any time without any precautions. The function log() is
// an example for such a function resident in the main program.
void log(char* msg) {
    printf("Log: %s\n", msg);
}

bool loadOverlay(char* overlayFileName, void* overlayAddr) {
    FILE* overlayFile;
    int overlayFileSize;
    overlayFile = fopen(overlayFileName, "rb");
    if (nullptr == overlayFile)
        return false;
    fseek(overlayFile, 0L, SEEK_END);
    overlayFileSize = ftell(overlayFile);
    fseek(overlayFile, 0L, SEEK_SET);
    fread(overlayAddr, overlayFileSize, 1, overlayFile);
    fclose(overlayFile);
    return true;
}

void main() {
    clrscr();

    log("Calling MENU from main");
    // The symbols _MENU_LOAD__ and _MENU_SIZE__ were generated by the
    // linker. They contain the overlay area address and size specific to a
    // certain program.
    if (loadOverlay("menu.ovl", _MENU_LOAD__)) {

        // The linker makes sure that the call to foo() ends up at the right mem
        // addr. However it's up to user to make sure that the - right - overlay
        // is actually loaded before making the the call.
        foo();
    }

    log("Calling LEVEL1 from main");
    // Replacing one overlay with another one can only happen from the main
    // program. This implies that an overlay can never load another overlay.
    if (loadOverlay("level1.ovl", _LEVEL1_LOAD__)) {
        bar();
    }

    log("Calling LEVEL2 from main");
    if (loadOverlay("level2.ovl", _LEVEL2_LOAD__)) {
        foobar();
    }

	printf("%u bytes free.\n", _heapmemavail());
    while(true);
}
